// /components/CozeExecutor.tsx
"use client";
import { useState, useEffect } from "react";
import {
  createGitHubPullRequest,
  getOpenPullRequests,
  approvePullRequest,
  closePullRequest,
} from "@/app/actions_github/actions";
import { executeCozeAgent, sendTelegramDocument } from "@/app/actions";
import { supabaseAdmin } from "@/hooks/supabase";
import { useAppContext } from "@/contexts/AppContext";
import { saveAs } from "file-saver";
import { Light as SyntaxHighlighter } from "react-syntax-highlighter";
import { docco } from "react-syntax-highlighter/dist/esm/styles/hljs";
import { FaInfoCircle, FaTelegramPlane, FaTrash, FaExternalLinkAlt, FaDatabase, FaRocket, FaGithub } from "react-icons/fa";

interface FileEntry {
  path: string;
  content: string;
  extension: string;
}

interface CozeResponse {
  id: string;
  bot_id: string;
  user_id: string;
  content: string;
  response: any;
  metadata: any;
  created_at: string;
}

const Tooltip = ({ children, text }: { children: React.ReactNode; text: string }) => {
  const [isVisible, setIsVisible] = useState(false);

  const handleToggle = () => setIsVisible((prev) => !prev);

  return (
    <div className="relative inline-block">
      <div onClick={handleToggle} onTouchStart={handleToggle}>
        {children}
      </div>
      {isVisible && (
        <div className="absolute z-10 p-2 bg-gray-700 text-white text-[10px] rounded shadow-lg w-64 -mt-2 ml-4 whitespace-pre-line">
          {text}
        </div>
      )}
    </div>
  );
};

export default function CozeExecutor({
  botId = "7483269209293275191",
  userId = "341503612082",
}: {
  botId?: string;
  userId?: string;
}) {
  const [response, setResponse] = useState<string>("");
  const [content, setContent] = useState<string>("Generate code components");
  const [files, setFiles] = useState<FileEntry[]>([]);
  const [savedFiles, setSavedFiles] = useState<FileEntry[]>([]);
  const [cozeResponses, setCozeResponses] = useState<CozeResponse[]>([]);
  const [error, setError] = useState<string>("");
  const [loading, setLoading] = useState(false);
  const [packageJsonInput, setPackageJsonInput] = useState<string>("");
  const [newModules, setNewModules] = useState<string[]>([]);
  const { user, openLink } = useAppContext();

  const [repoUrl, setRepoUrl] = useState<string>("https://github.com/salavey13/cartest");
  const [prTitle, setPrTitle] = useState<string>("Update from CozeExecutor");
  const [prDescription, setPrDescription] = useState<string>("Auto-generated by CozeExecutor - fuck yeah!");
  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set());
  const [openPRs, setOpenPRs] = useState<any[]>([]);

  useEffect(() => {
    const loadData = async () => {
      if (!user) return;
      try {
        setError("");
        const { data: userData, error: userError } = await supabaseAdmin
          .from("users")
          .select("metadata")
          .eq("user_id", user.id)
          .single();
        if (userError) throw userError;
        if (userData?.metadata?.generated_files) {
          const parsedSavedFiles = Array.isArray(userData.metadata.generated_files)
            ? userData.metadata.generated_files.map((f: any) => ({
                path: f.path,
                content: f.code,
                extension: f.extension,
              }))
            : [];
          setSavedFiles(parsedSavedFiles);
        }

        const { data: responses, error: responsesError } = await supabaseAdmin
          .from("coze_responses")
          .select("*")
          .eq("user_id", user.id)
          .order("created_at", { ascending: false });
        if (responsesError) throw responsesError;
        setCozeResponses(responses || []);
      } catch (err) {
        setError("Не удалось загрузить данные: " + (err as Error).message);
      }
    };
    if (user) loadData();
  }, [user]);

  const parseFilesFromJson = (json: any): FileEntry[] => {
    const entries: FileEntry[] = [];
    try {
      json.new_components?.forEach((c: any) => {
        const match = c.code.match(/\/\/ File: (.+)\n/);
        if (match) {
          entries.push({
            path: match[1],
            content: c.code,
            extension: match[1].split(".").pop() || "tsx",
          });
        }
      });

      json.new_pages?.forEach((p: any) => {
        entries.push({
          path: p.route,
          content: p.code,
          extension: p.route.split(".").pop() || "tsx",
        });
      });

      if (json.new_actions && json.new_actions.length > 0) {
        const firstActionName = json.new_actions[0].name;
        const subfolderPrefix = firstActionName.match(/^[a-z]+/)?.[0] || "misc";
        const subfolder = `actions_${subfolderPrefix}`;
        const actionsContent = json.new_actions
          .map((a: any) => `export async function ${a.name}(${a.params || ""}) {\n${a.code}\n}`)
          .join("\n\n");
        entries.push({
          path: `app/${subfolder}/actions.ts`,
          content: actionsContent,
          extension: "ts",
        });
      }

      json.supabase_migrations?.forEach((m: any) => {
        entries.push({
          path: `supabase/migrations/${m.name}.sql`,
          content: m.sql,
          extension: "sql",
        });
      });
    } catch (err) {
      setError("Ошибка парсинга JSON: " + (err as Error).message);
    }
    return entries;
  };

  const parseFilesFromText = (text: string): FileEntry[] => {
    const entries: FileEntry[] = [];
    const supportedLanguages = ["typescript", "tsx", "ts", "sql"];
    const importRegex = /import\s+.*\s+from\s+['"]([^'"]+)['"]/g;
    const detectedModules: Set<string> = new Set();

    try {
      const codeBlocks = text.match(/