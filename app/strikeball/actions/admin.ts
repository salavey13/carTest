"use server";

import { supabaseAdmin } from "@/hooks/supabase";
import { logger } from "@/lib/logger";

/**
 * Validate a scanned QR code.
 * Supports: 
 * - user_{id} (Profile check)
 * - gear_buy_{id} (Purchase check)
 * - lobby_{id} (Lobby check)
 */
export async function validateScannedCode(adminUserId: string, rawCode: string) {
  // 1. Verify Admin Permissions
  const { data: user } = await supabaseAdmin.from("users").select("role").eq("user_id", adminUserId).single();
  // Allow 'admin', 'vprAdmin', or maybe a new 'organizer' role. For now, strict admin.
  const isAdmin = user?.role === 'admin' || user?.role === 'vprAdmin';
  
  if (!isAdmin) return { success: false, error: "ACCESS DENIED: NOT AN ADMIN" };

  try {
    let payload = rawCode;
    // Clean up if it's a full URL
    if (rawCode.includes('startapp=')) {
        payload = rawCode.split('startapp=')[1].split('&')[0];
    }

    // --- CASE A: GEAR PURCHASE ---
    if (payload.startsWith('gear_buy_')) {
        // Expected: gear_buy_{itemId}_{timestamp} OR just gear_buy_{itemId} if generated by catalog
        // Ideally, we need the Purchase ID to mark *that specific transaction* as collected.
        // But the "Catalog PDF" generates generic QRs for the ITEM, not a specific purchase.
        // So this scans to "Issue 1 unit of Item X to User Y" (User Y needs to be selected or scanned contextually).
        
        // Let's assume we scan a User's "Digital Receipt" which SHOULD contain the Purchase ID in a real scenario.
        // But if we scan the Catalog, we are doing a "Quick Sale" or "Quick Issue".
        
        // Let's handle the "Catalog Scan" -> "Deduct 1 from Stock" flow.
        const itemId = payload.replace('gear_buy_', '').split('_')[0];
        
        const { data: item, error } = await supabaseAdmin.from("cars").select("*").eq("id", itemId).single();
        if (error || !item) throw new Error("Item not found");
        
        const newQuantity = parseInt(item.quantity || "0") - 1;
        await supabaseAdmin.from("cars").update({ quantity: newQuantity }).eq("id", itemId);

        return { 
            success: true, 
            type: 'gear_issue', 
            data: { 
                name: `${item.make} ${item.model}`, 
                remaining: newQuantity 
            } 
        };
    }

    // --- CASE B: LOBBY CHECK ---
    if (payload.startsWith('lobby_')) {
        const lobbyId = payload.replace('lobby_', '');
        const { data: lobby } = await supabaseAdmin.from("lobbies").select("*").eq("id", lobbyId).single();
        if (!lobby) throw new Error("Lobby not found");
        
        const { count } = await supabaseAdmin.from("lobby_members").select("*", { count: 'exact', head: true }).eq("lobby_id", lobbyId);
        
        return {
            success: true,
            type: 'lobby_info',
            data: {
                name: lobby.name,
                status: lobby.status,
                count: count || 0
            }
        };
    }

    return { success: false, error: "UNKNOWN CODE FORMAT" };

  } catch (e: any) {
    return { success: false, error: e.message };
  }
}